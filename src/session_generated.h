// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SESSION_BAKTSIU_IO_H_
#define FLATBUFFERS_GENERATED_SESSION_BAKTSIU_IO_H_

#include "flatbuffers/flatbuffers.h"

namespace baktsiu {
namespace io {

struct Image;
struct ImageBuilder;

struct Session;
struct SessionBuilder;

enum ColorPrimary {
  ColorPrimary_BT_709 = 0,
  ColorPrimary_DCI_P3 = 1,
  ColorPrimary_BT_2020 = 2,
  ColorPrimary_ACES_AP0 = 3,
  ColorPrimary_ACES_AP1 = 4,
  ColorPrimary_MIN = ColorPrimary_BT_709,
  ColorPrimary_MAX = ColorPrimary_ACES_AP1
};

inline const ColorPrimary (&EnumValuesColorPrimary())[5] {
  static const ColorPrimary values[] = {
    ColorPrimary_BT_709,
    ColorPrimary_DCI_P3,
    ColorPrimary_BT_2020,
    ColorPrimary_ACES_AP0,
    ColorPrimary_ACES_AP1
  };
  return values;
}

inline const char * const *EnumNamesColorPrimary() {
  static const char * const names[6] = {
    "BT_709",
    "DCI_P3",
    "BT_2020",
    "ACES_AP0",
    "ACES_AP1",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorPrimary(ColorPrimary e) {
  if (flatbuffers::IsOutRange(e, ColorPrimary_BT_709, ColorPrimary_ACES_AP1)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorPrimary()[index];
}

enum ColorEncoding {
  ColorEncoding_Linear = 0,
  ColorEncoding_BT_2020 = 1,
  ColorEncoding_BT_2100_HLG = 2,
  ColorEncoding_BT_2100_PQ = 3,
  ColorEncoding_BT_709 = 4,
  ColorEncoding_sRGB = 5,
  ColorEncoding_MIN = ColorEncoding_Linear,
  ColorEncoding_MAX = ColorEncoding_sRGB
};

inline const ColorEncoding (&EnumValuesColorEncoding())[6] {
  static const ColorEncoding values[] = {
    ColorEncoding_Linear,
    ColorEncoding_BT_2020,
    ColorEncoding_BT_2100_HLG,
    ColorEncoding_BT_2100_PQ,
    ColorEncoding_BT_709,
    ColorEncoding_sRGB
  };
  return values;
}

inline const char * const *EnumNamesColorEncoding() {
  static const char * const names[7] = {
    "Linear",
    "BT_2020",
    "BT_2100_HLG",
    "BT_2100_PQ",
    "BT_709",
    "sRGB",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorEncoding(ColorEncoding e) {
  if (flatbuffers::IsOutRange(e, ColorEncoding_Linear, ColorEncoding_sRGB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorEncoding()[index];
}

enum DisplayMode {
  DisplayMode_Top = 0,
  DisplayMode_Split = 1,
  DisplayMode_Column = 2,
  DisplayMode_MIN = DisplayMode_Top,
  DisplayMode_MAX = DisplayMode_Column
};

inline const DisplayMode (&EnumValuesDisplayMode())[3] {
  static const DisplayMode values[] = {
    DisplayMode_Top,
    DisplayMode_Split,
    DisplayMode_Column
  };
  return values;
}

inline const char * const *EnumNamesDisplayMode() {
  static const char * const names[4] = {
    "Top",
    "Split",
    "Column",
    nullptr
  };
  return names;
}

inline const char *EnumNameDisplayMode(DisplayMode e) {
  if (flatbuffers::IsOutRange(e, DisplayMode_Top, DisplayMode_Column)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDisplayMode()[index];
}

struct Image FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PATH = 6,
    VT_COLORPRIMARY = 8,
    VT_COLORENCODING = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  baktsiu::io::ColorPrimary colorPrimary() const {
    return static_cast<baktsiu::io::ColorPrimary>(GetField<int8_t>(VT_COLORPRIMARY, 0));
  }
  baktsiu::io::ColorEncoding colorEncoding() const {
    return static_cast<baktsiu::io::ColorEncoding>(GetField<int8_t>(VT_COLORENCODING, 5));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           VerifyField<int8_t>(verifier, VT_COLORPRIMARY) &&
           VerifyField<int8_t>(verifier, VT_COLORENCODING) &&
           verifier.EndTable();
  }
};

struct ImageBuilder {
  typedef Image Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Image::VT_NAME, name);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(Image::VT_PATH, path);
  }
  void add_colorPrimary(baktsiu::io::ColorPrimary colorPrimary) {
    fbb_.AddElement<int8_t>(Image::VT_COLORPRIMARY, static_cast<int8_t>(colorPrimary), 0);
  }
  void add_colorEncoding(baktsiu::io::ColorEncoding colorEncoding) {
    fbb_.AddElement<int8_t>(Image::VT_COLORENCODING, static_cast<int8_t>(colorEncoding), 5);
  }
  explicit ImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageBuilder &operator=(const ImageBuilder &);
  flatbuffers::Offset<Image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Image>(end);
    return o;
  }
};

inline flatbuffers::Offset<Image> CreateImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    baktsiu::io::ColorPrimary colorPrimary = baktsiu::io::ColorPrimary_BT_709,
    baktsiu::io::ColorEncoding colorEncoding = baktsiu::io::ColorEncoding_sRGB) {
  ImageBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_name(name);
  builder_.add_colorEncoding(colorEncoding);
  builder_.add_colorPrimary(colorPrimary);
  return builder_.Finish();
}

inline flatbuffers::Offset<Image> CreateImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *path = nullptr,
    baktsiu::io::ColorPrimary colorPrimary = baktsiu::io::ColorPrimary_BT_709,
    baktsiu::io::ColorEncoding colorEncoding = baktsiu::io::ColorEncoding_sRGB) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return baktsiu::io::CreateImage(
      _fbb,
      name__,
      path__,
      colorPrimary,
      colorEncoding);
}

struct Session FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SessionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_IMAGES = 6,
    VT_MODE = 8,
    VT_TOPIMAGEINDEX = 10,
    VT_CMPIMAGEINDEX = 12,
    VT_IMAGESCALE = 14,
    VT_VIEWSPLITPOS = 16,
    VT_PROPWINDOWHSPLITRATIO = 18,
    VT_DISPLAYGAMMA = 20,
    VT_EXPOSUREVALUE = 22
  };
  uint16_t magic() const {
    return GetField<uint16_t>(VT_MAGIC, 7777);
  }
  const flatbuffers::Vector<flatbuffers::Offset<baktsiu::io::Image>> *images() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<baktsiu::io::Image>> *>(VT_IMAGES);
  }
  baktsiu::io::DisplayMode mode() const {
    return static_cast<baktsiu::io::DisplayMode>(GetField<int8_t>(VT_MODE, 0));
  }
  int32_t topImageIndex() const {
    return GetField<int32_t>(VT_TOPIMAGEINDEX, -1);
  }
  int32_t cmpImageIndex() const {
    return GetField<int32_t>(VT_CMPIMAGEINDEX, -1);
  }
  float imageScale() const {
    return GetField<float>(VT_IMAGESCALE, 1.0f);
  }
  float viewSplitPos() const {
    return GetField<float>(VT_VIEWSPLITPOS, 0.5f);
  }
  float propWindowHSplitRatio() const {
    return GetField<float>(VT_PROPWINDOWHSPLITRATIO, 0.65f);
  }
  float displayGamma() const {
    return GetField<float>(VT_DISPLAYGAMMA, 2.2f);
  }
  float exposureValue() const {
    return GetField<float>(VT_EXPOSUREVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_MAGIC) &&
           VerifyOffset(verifier, VT_IMAGES) &&
           verifier.VerifyVector(images()) &&
           verifier.VerifyVectorOfTables(images()) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<int32_t>(verifier, VT_TOPIMAGEINDEX) &&
           VerifyField<int32_t>(verifier, VT_CMPIMAGEINDEX) &&
           VerifyField<float>(verifier, VT_IMAGESCALE) &&
           VerifyField<float>(verifier, VT_VIEWSPLITPOS) &&
           VerifyField<float>(verifier, VT_PROPWINDOWHSPLITRATIO) &&
           VerifyField<float>(verifier, VT_DISPLAYGAMMA) &&
           VerifyField<float>(verifier, VT_EXPOSUREVALUE) &&
           verifier.EndTable();
  }
};

struct SessionBuilder {
  typedef Session Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(uint16_t magic) {
    fbb_.AddElement<uint16_t>(Session::VT_MAGIC, magic, 7777);
  }
  void add_images(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<baktsiu::io::Image>>> images) {
    fbb_.AddOffset(Session::VT_IMAGES, images);
  }
  void add_mode(baktsiu::io::DisplayMode mode) {
    fbb_.AddElement<int8_t>(Session::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_topImageIndex(int32_t topImageIndex) {
    fbb_.AddElement<int32_t>(Session::VT_TOPIMAGEINDEX, topImageIndex, -1);
  }
  void add_cmpImageIndex(int32_t cmpImageIndex) {
    fbb_.AddElement<int32_t>(Session::VT_CMPIMAGEINDEX, cmpImageIndex, -1);
  }
  void add_imageScale(float imageScale) {
    fbb_.AddElement<float>(Session::VT_IMAGESCALE, imageScale, 1.0f);
  }
  void add_viewSplitPos(float viewSplitPos) {
    fbb_.AddElement<float>(Session::VT_VIEWSPLITPOS, viewSplitPos, 0.5f);
  }
  void add_propWindowHSplitRatio(float propWindowHSplitRatio) {
    fbb_.AddElement<float>(Session::VT_PROPWINDOWHSPLITRATIO, propWindowHSplitRatio, 0.65f);
  }
  void add_displayGamma(float displayGamma) {
    fbb_.AddElement<float>(Session::VT_DISPLAYGAMMA, displayGamma, 2.2f);
  }
  void add_exposureValue(float exposureValue) {
    fbb_.AddElement<float>(Session::VT_EXPOSUREVALUE, exposureValue, 0.0f);
  }
  explicit SessionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SessionBuilder &operator=(const SessionBuilder &);
  flatbuffers::Offset<Session> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Session>(end);
    return o;
  }
};

inline flatbuffers::Offset<Session> CreateSession(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t magic = 7777,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<baktsiu::io::Image>>> images = 0,
    baktsiu::io::DisplayMode mode = baktsiu::io::DisplayMode_Top,
    int32_t topImageIndex = -1,
    int32_t cmpImageIndex = -1,
    float imageScale = 1.0f,
    float viewSplitPos = 0.5f,
    float propWindowHSplitRatio = 0.65f,
    float displayGamma = 2.2f,
    float exposureValue = 0.0f) {
  SessionBuilder builder_(_fbb);
  builder_.add_exposureValue(exposureValue);
  builder_.add_displayGamma(displayGamma);
  builder_.add_propWindowHSplitRatio(propWindowHSplitRatio);
  builder_.add_viewSplitPos(viewSplitPos);
  builder_.add_imageScale(imageScale);
  builder_.add_cmpImageIndex(cmpImageIndex);
  builder_.add_topImageIndex(topImageIndex);
  builder_.add_images(images);
  builder_.add_magic(magic);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Session> CreateSessionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t magic = 7777,
    const std::vector<flatbuffers::Offset<baktsiu::io::Image>> *images = nullptr,
    baktsiu::io::DisplayMode mode = baktsiu::io::DisplayMode_Top,
    int32_t topImageIndex = -1,
    int32_t cmpImageIndex = -1,
    float imageScale = 1.0f,
    float viewSplitPos = 0.5f,
    float propWindowHSplitRatio = 0.65f,
    float displayGamma = 2.2f,
    float exposureValue = 0.0f) {
  auto images__ = images ? _fbb.CreateVector<flatbuffers::Offset<baktsiu::io::Image>>(*images) : 0;
  return baktsiu::io::CreateSession(
      _fbb,
      magic,
      images__,
      mode,
      topImageIndex,
      cmpImageIndex,
      imageScale,
      viewSplitPos,
      propWindowHSplitRatio,
      displayGamma,
      exposureValue);
}

inline const baktsiu::io::Session *GetSession(const void *buf) {
  return flatbuffers::GetRoot<baktsiu::io::Session>(buf);
}

inline const baktsiu::io::Session *GetSizePrefixedSession(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<baktsiu::io::Session>(buf);
}

inline bool VerifySessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<baktsiu::io::Session>(nullptr);
}

inline bool VerifySizePrefixedSessionBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<baktsiu::io::Session>(nullptr);
}

inline void FinishSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<baktsiu::io::Session> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSessionBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<baktsiu::io::Session> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace io
}  // namespace baktsiu

#endif  // FLATBUFFERS_GENERATED_SESSION_BAKTSIU_IO_H_
